<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>File Manager</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif; margin: 0; padding: 24px; }
    header { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }
    h1 { font-size: 20px; margin: 0; }
    .bar { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px; }
    input, button { font-size: 14px; padding: 6px 10px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; border-bottom: 1px solid #ddd3; padding: 8px; }
    tr:hover { background: #eee2; }
    .name { cursor: pointer; }
    .dir { font-weight: 600; }
    .muted { opacity: .75; }
    .row-actions button { margin-right: 6px; }
    .path { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    /* icon for items */
    .icon { display: inline-flex; align-items: center; justify-content: center; width: 28px; height: 20px; margin-right: 8px; font-size: 14px; }
    .icon.dir { color: #0b69ff; }
    .icon.file { color: #666; }
    .footer { margin-top: 28px; text-align: center; color: #666; font-size: 13px; opacity: 0.9; }
  </style>
  <style>
    /* Upload list / progress */
    #uploads { margin-top: 12px; display: flex; flex-direction: column; gap: 8px; }
    .upload-item { display: flex; gap: 12px; align-items: center; }
    .upload-item .meta { min-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .upload-item progress { width: 320px; height: 14px; }
    .upload-item .status { font-size: 12px; color: #666; min-width: 120px; }
  </style>
  <script>
    const api = {
      list: async (path = "") => (await fetch(`/api/list?path=${encodeURIComponent(path)}`)).json(),
      download: (path) => { window.location.href = `/api/download?path=${encodeURIComponent(path)}`; },
      upload: async (path, files) => {
        const fd = new FormData();
        for (const f of files) fd.append('files', f);
        const res = await fetch(`/api/upload?path=${encodeURIComponent(path)}`, { method: 'POST', body: fd });
        if (!res.ok) throw new Error('‰∏ä‰º†Â§±Ë¥•');
      },
      mkdir: async (path, name) => {
        const res = await fetch('/api/mkdir', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path, name }) });
        if (!res.ok) throw new Error('ÂàõÂª∫ÁõÆÂΩïÂ§±Ë¥•');
      },
      rename: async (path, oldName, newName) => {
        const res = await fetch('/api/rename', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path, oldName, newName }) });
        if (!res.ok) throw new Error('ÈáçÂëΩÂêçÂ§±Ë¥•');
      },
      del: async (path, name) => {
        const res = await fetch('/api/delete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path, name }) });
        if (!res.ok) throw new Error('Âà†Èô§Â§±Ë¥•ÔºàÁõÆÂΩïÈúÄ‰∏∫Á©∫Ôºâ');
      }
    };

    let state = { path: "" };

    async function refresh() {
      const data = await api.list(state.path);
      state.path = data.cwd || "";
      document.querySelector('#cwd').textContent = state.path || "/";
      const tbody = document.querySelector('#list');
      tbody.innerHTML = '';
      if (state.path) addRow(tbody, { name: "..", isDir: true, size: 0, mtime: 0 }, true);
      for (const it of data.items) {
        // Defensive: skip hidden files/dirs starting with '.'
        if (it.name && it.name.startsWith('.')) continue;
        addRow(tbody, it, false);
      }
    }

    function addRow(tbody, item, isUp) {
      const tr = document.createElement('tr');
      const nameTd = document.createElement('td');
      nameTd.className = 'name';
      const a = document.createElement('span');
      a.textContent = item.name;
      const icon = document.createElement('span');
      icon.className = 'icon ' + (item.isDir ? 'dir' : 'file');
      // Use emoji as fallback icon - simple and visible across platforms
      icon.textContent = item.isDir ? 'üìÅ' : 'üìÑ';
      nameTd.appendChild(icon);
      if (item.isDir) a.classList.add('dir');
      a.onclick = () => {
        if (item.isDir) {
          if (isUp) {
            const parts = (state.path || '').split('/').filter(Boolean); parts.pop();
            state.path = parts.join('/');
          } else {
            state.path = [state.path, item.name].filter(Boolean).join('/');
          }
          refresh();
        } else {
          api.download([state.path, item.name].filter(Boolean).join('/'));
        }
      };
      nameTd.appendChild(a);
      const sizeTd = document.createElement('td');
      sizeTd.textContent = item.isDir ? '-' : humanSize(item.size);
      const mtimeTd = document.createElement('td');
      mtimeTd.className = 'muted';
      mtimeTd.textContent = item.mtime ? new Date(item.mtime * 1000).toLocaleString() : '';
      const actTd = document.createElement('td');
      actTd.className = 'row-actions';
      if (!isUp) {
        const renameBtn = document.createElement('button');
        renameBtn.textContent = 'ÈáçÂëΩÂêç';
        renameBtn.onclick = async () => {
          const newName = prompt('ËæìÂÖ•Êñ∞ÂêçÁß∞', item.name);
          if (!newName || newName === item.name) return;
          await api.rename(state.path, item.name, newName); await refresh();
        };
        const delBtn = document.createElement('button');
        delBtn.textContent = 'Âà†Èô§';
        delBtn.onclick = async () => { if (confirm('Á°ÆÂÆöÂà†Èô§Ôºü')) { await api.del(state.path, item.name); await refresh(); } };
        actTd.append(renameBtn, delBtn);
      }
      tr.append(nameTd, sizeTd, mtimeTd, actTd);
      tbody.appendChild(tr);
    }

    function humanSize(n) {
      const u = ['B','KB','MB','GB','TB'];
      let i = 0; while (n >= 1024 && i < u.length - 1) { n /= 1024; i++; }
      return `${n.toFixed(1)} ${u[i]}`;
    }

    async function onUploadChanged(e) {
      const files = e.target.files;
      if (!files || files.length === 0) return;
      // Upload each file; use resumable upload for large files to avoid 413 from proxies
      const MAX_SINGLE_UPLOAD = 50 * 1024 * 1024; // 50MB threshold for single request
      for (const f of files) {
        try {
          if (f.size > MAX_SINGLE_UPLOAD) {
            await uploadResumable(f);
          } else {
            // small file ‚Äî use XHR with progress
            const uploadEl = createUploadItem(f.name, f.size);
            await uploadWithProgress(state.path, f, (loaded, total) => updateUploadProgress(uploadEl, loaded));
            updateUploadProgress(uploadEl, f.size, true);
          }
        } catch (err) {
          console.error('Upload failed for', f.name, err);
          alert(`‰∏ä‰º†Â§±Ë¥•: ${f.name} ‚Äî ${err}`);
          break;
        }
      }
      e.target.value = '';
      refresh();
    }

    async function uploadResumable(file) {
      // create/init upload session
      const storageKey = `upload:${state.path}:${file.name}:${file.size}`;
      let uploadId = localStorage.getItem(storageKey);
      let offset = 0;
      // If we have an uploadId already, query status to resume
      if (uploadId) {
        try {
          const st = await fetch(`/api/upload/status?uploadId=${encodeURIComponent(uploadId)}`);
          if (st.ok) {
            const data = await st.json();
            offset = data.received || 0;
            console.log('Resuming upload', file.name, 'from', offset);
          } else {
            // unknown id on server; forget and re-init
            uploadId = null;
            localStorage.removeItem(storageKey);
          }
        } catch (e) {
          // If status check fails, fall back to re-init
          uploadId = null;
          localStorage.removeItem(storageKey);
        }
      }
      // create/init upload session if needed
      if (!uploadId) {
        const initRes = await fetch('/api/upload/init', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path: state.path, filename: file.name, totalSize: file.size })
        });
        if (!initRes.ok) throw new Error('ÂàùÂßãÂåñ‰∏ä‰º†Â§±Ë¥•');
        const initData = await initRes.json();
        uploadId = initData.uploadId;
        localStorage.setItem(storageKey, uploadId);
      }
      const chunkSize = 5 * 1024 * 1024; // 5MB
      let attempt = 0;
      const uploadEl = createUploadItem(file.name, file.size);
      while (offset < file.size) {
        const end = Math.min(offset + chunkSize, file.size);
        const blob = file.slice(offset, end);
        const fd = new FormData();
        fd.append('uploadId', uploadId);
        fd.append('offset', String(offset));
        fd.append('chunk', blob, file.name);
        // simple retry on transient errors
        let ok = false;
        for (attempt = 0; attempt < 3 && !ok; attempt++) {
          const res = await fetch('/api/upload/chunk', { method: 'POST', body: fd });
          if (res.ok) {
            const data = await res.json();
            offset = data.received || end;
            ok = true;
            console.log(`Uploaded chunk, new offset=${offset}`);
            updateUploadProgress(uploadEl, offset);
          } else {
            // small backoff
            await new Promise(r => setTimeout(r, 500 * (attempt + 1)));
          }
        }
        if (!ok) throw new Error('‰∏ä‰º†ÂàÜÁâáÂ§±Ë¥•');
      }
      // finalize
      const comp = await fetch('/api/upload/complete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ uploadId }) });
      if (!comp.ok) {
        const txt = await comp.text();
        throw new Error('ÂÆåÊàêÂêàÂπ∂Â§±Ë¥•: ' + txt);
      }
      // cleanup local storage
      localStorage.removeItem(storageKey);
      updateUploadProgress(uploadEl, file.size, true);
      console.log('Upload complete for', file.name);
      return true;
    }

    // Single-file upload with progress (for smaller files)
    function uploadWithProgress(path, file, onProgress) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', `/api/upload?path=${encodeURIComponent(path)}`);
        xhr.onload = () => {
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve(JSON.parse(xhr.responseText));
          } else {
            reject(new Error(`‰∏ä‰º†Â§±Ë¥•: ${xhr.status} ${xhr.statusText}`));
          }
        };
        xhr.onerror = () => reject(new Error('ÁΩëÁªúÈîôËØØ'));
        xhr.upload.onprogress = (ev) => {
          if (ev.lengthComputable) onProgress(ev.loaded, ev.total);
        };
        const fd = new FormData(); fd.append('files', file);
        xhr.send(fd);
      });
    }

    function createUploadItem(name, total) {
      const uploads = document.querySelector('#uploads');
      const wrap = document.createElement('div'); wrap.className = 'upload-item';
      const meta = document.createElement('div'); meta.className = 'meta'; meta.textContent = name;
      const prog = document.createElement('progress'); prog.max = total; prog.value = 0;
      const status = document.createElement('div'); status.className = 'status'; status.textContent = 'ÂáÜÂ§á‰∏≠';
      wrap.append(meta, prog, status);
      uploads.prepend(wrap);
      return { wrap, prog, status };
    }

    function updateUploadProgress(el, loaded, done=false) {
      try {
        el.prog.value = loaded;
        el.status.textContent = done ? 'ÂÆåÊàê' : `${Math.round((loaded/el.prog.max)*100)}% (${loaded}/${el.prog.max} bytes)`;
      } catch(e) { console.debug(e); }
    }

    async function onMkdir() {
      const name = prompt('ËæìÂÖ•ÁõÆÂΩïÂêç');
      if (!name) return;
      await api.mkdir(state.path, name);
      refresh();
    }

    async function onGoRoot() { state.path = ""; refresh(); }

    window.addEventListener('DOMContentLoaded', () => {
      document.querySelector('#upload').addEventListener('change', onUploadChanged);
      const uploadBtn = document.querySelector('#uploadBtn');
      if (uploadBtn) uploadBtn.addEventListener('click', () => document.querySelector('#upload').click());
      document.querySelector('#mkdir').addEventListener('click', onMkdir);
      document.querySelector('#root').addEventListener('click', onGoRoot);
      refresh();
    });
  </script>
</head>
<body>
  <header>
    <h1>File Manager</h1>
  </header>
  <div class="bar">
    <button id="root">ÂõûÂà∞Ê†πÁõÆÂΩï</button>
    <button id="mkdir">Êñ∞Âª∫ÁõÆÂΩï</button>
    <label>
      <button id="uploadBtn" type="button">‰∏ä‰º†Êñá‰ª∂</button>
      <input id="upload" type="file" multiple style="display:none" />
    </label>
    <span class="path">ÂΩìÂâçË∑ØÂæÑÔºö<span id="cwd">/</span></span>
  </div>
  <div id="uploads" aria-live="polite"></div>
  <table>
    <thead>
      <tr><th>ÂêçÁß∞</th><th>Â§ßÂ∞è</th><th>‰øÆÊîπÊó∂Èó¥</th><th>Êìç‰Ωú</th></tr>
    </thead>
    <tbody id="list"></tbody>
  </table>
  <footer class="footer">¬© 2025 ÊàêÈÉΩÁ†¥ÊôìÁü≥ÁßëÊäÄÊúâÈôêÂÖ¨Âè∏ ÁâàÊùÉÊâÄÊúâ„ÄÇ</footer>
</body>
</html>


